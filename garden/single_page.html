<html>
<head>
<title>Garden: Table of Contents</title>
<link rel="stylesheet" href="../style/main.css" />
<link rel="stylesheet" href="../style/docs.css" />
</head>
<body>
<h1>Garden -- A Functional Template Language</h1>
<h2>VERSION 1-PREDRAFT3</h2>
<h2>Table of Contents</h2>
<ul>
<li>Core Concepts
<ul>
<li>
<a href="#intro">Introduction</a>
</li>
<li>
<a href="#namespaces">Namespaces</a>
</li>
<li>
<a href="#statements">Statements</a>
</li>
<li>
<a href="#templates">Templates</a>
</li>
<li>
<a href="#dicts">Dictionaries</a>
</li>
<li>
<a href="#imports">Importation</a>
</li>
<li>
<a href="#exports">Exportation</a>
</li>

</ul>
</li>
<li>Template Language
<ul>
<li>
<a href="#vars">Variables</a>
</li>
<li>
<a href="#aliases">Local Aliases</a>
</li>
<li>
<a href="#methods">Method calls</a>
</li>
<li>
<a href="#nested">Nested Templates</a>
</li>
<li>
<a href="#apply">Applying Templates</a>
</li>
<li>
<a href="#conditional">Conditionals</a>
</li>
<li>
<a href="#comments">Comments</a>
</li>

</ul>
</li>
<li>Customization and Extensions
<ul>
<li>
<a href="#syntax">Overriding Syntax</a>
</li>
<li>
<a href="#globals">Global Variables</a>
</li>
<li>
<a href="#plugins">Plugins</a>
</li>
<li>
<a href="#json">JSON Blocks</a>
</li>
<li>
<a href="#ideas">Future ideas</a>
</li>

</ul>
</li>

</ul>
<h2>Core Concepts</h2>
<h3 name="intro" id="intro">Introduction</h3>
<p>
Garden is a general-purpose functional template langauge. It doesn't
care what it's source textual format is and offers a great deal of flexibility 
without forcing too much application logic into your templates.
</p>
<p>
It offers a very different approach to recursion (looping) and conditional
sections of templates than most template engines, having been inspired by
StringTemplate (a Java-based functional template engine) and my own previous 
project: Flower (a Perl 6 XML Application Engine, with a TAL/METAL template
language included.)
</p>
<p>
One of the defining features of Garden is that it is very customizable.
It offers a flexible way to override certain syntax, to ensure the Garden
statements don't conflict with the textual content of your templates.
It also offers optional extensions that individual implementations may
choose to implement, and templates can request individually.
</p>
<p>
This specification defines the full language, as well as a few recommended
extensions. An implementation must implement all non-extension features
in order to comply with the specification.
</p>


<h3 name="namespaces" id="namespaces">Namespaces</h3>
<p>
In Garden, all templates, dictionaries, or localized settings are contained
in a namespace. Typically, each namespace is represented by a single file in 
a folder. The global Garden object can be given a list of folders to search 
for namespace files in. Individual namespaces can add additional folders to 
their search path. The search folders can use sub-folders to break up 
the namespaces better.
</p>
<p>
In the examples below, except where stated otherwise, it is assumed we have
a single search path, considing of the <i>./templates</i> folder.
</p>
<p>
The Garden object should have a <code>get()</code> method which returns a 
template to the application. 
Template names can be simple strings such as <i class="t">example</i>, 
or nested names such as <i class="t">common/example/mytemplate</i> 
When you call the <code>get()</code> method, or call a template from inside 
another template, you are always referring to the 
<em class="t">template</em> you want, not the <em class="n">namespace</em>
(although as the following will show, that can sometimes be the same name.)
</p>
<h4>Default Template</h4>
<p>
A namespace can have a default template. That is, a template with the same
name as the namespace itself. So for instance, if you have a namespace file
called <i class="n">./templates/example.tmpl</i> you could make a template 
within that  file called <i class="t">example</i> which would then be used 
as the default template. 
Thus from any other namespace, calling 
<code><i class="s">[[</i><i class="t">example()</i><i class="s">]]</i></code> would find 
the  <i class="n">example</i> namespace, and parse the 
<i class="t">example</i> template from within it.
</p>
<h4>Finding Templates</h4>
<p>
Okay, so if you use <code>get('common/example/mytemplate')</code> in the 
program, or 
<code><i class="s">[[</i><i class="t">common/example/mytemplate()</i><i class="s">]]</i></code> 
in a template, 
Garden needs to determine what you are looking for. 
In the case above, it could be one of two things:
</p>
<ol>
<li>The <i class="t">mytemplate</i> template in the <i class="n">common/example/mytemplate</i> namespace.</li>
<li>The <i class="t">mytemplate</i> template in the <i class="n">common/example</i> namespace.</li>
</ol>
<p>
Well, first we look for a namespace with the given name, so if
<i class="n">./templates/common/example/mytemplate.tmpl</i> exists, 
we will return the <i class="t">mytemplate</i> template from that namespace.
</p>
<p>
If it does not exist, then we see if 
<i class="n">./templates/common/example.tmpl</i> exists,
and if it does, we return the 
<i class="t">mytemplate</i> template from that namespace.
</p>
<p>
All of this is fairly simple so far, except in the case where you have more
than one search path. In that case, the above tests are repeated in order
for each path. More specific paths must be at the top of the search path
list. So, as an example, given your search folders are:
</p>
<ol>
<li><i>./templates/advanced</i></li>
<li><i>./templates/default</i></li>
</ol>
<p>
And you request <i class="t">common/example/mytemplate</i>, 
the following order will be used to find the namespace for 
the <i class="t">mytemplate</i> template:
</p>
<ol>
<li><i class="t">./templates/advanced/common/example/mytemplate.tmpl</i></li>
<li><i class="t">./templates/advanced/common/example.tmpl</i></li>
<li><i class="t">./templates/default/common/example/mytemplate.tmpl</i></li>
<li><i class="t">./templates/default/common/example.tmpl</i></li>
</ol>


<h3 name="statements" id="statements">Statements</h3>
<p>
In namespace files, only two things are parsed: statements and blocks.
We'll get to the various kinds of block later, but for now let's focus on
statements.
</p>
<p>
Before that however, a rather large and important rule. 
<strong>Any text not recognized as a statement or block, is ignored.</strong>
That's right, we don't barf, or bail, or go "what the hell is that", we just
ignore it. If it's not one of the known statements (either core, or extension),
and it's not a known block (again, core or extension), then we ignore it.
</p>
<p>
Okay, with that out of the way, let's move on to the known statements and
what they do. Note: the list below is only for Core statements. Any
statements added by extensions will be listed in the documentation for
that extension.
</p>

<h4>The version statement</h4>
<p>
Using the <code class="b">version</code> statement declares that your template
requires at least the specified version of the Garden specification in order
to be properly parsed. It's use is simple:
</p>
<code class="block">
<b>version</b> <i>1</i>
</code>
<p>
Where you replace the <i>1</i> with whatever version you are depending upon.
</p>
<p>
By specifying a version, the Garden implementation can enable certain
version-specific features, or changes to any default syntax. If you do
not specify a version statement, backwards compatibility with version 1 is
assumed. Additional features may be enabled with the lack of a version number,
but only if enabling them is backwards compatible with version 1 templates.
</p>

<h4>The use statement</h4>
<p>
Some features in Garden are optional. These are called Extensions.
There are two kinds of extensions: Recommended Extensions, and Implementation
Extensions. The first kind, as the name suggests, are recommended to be
available in every implementation, but that is not guaranteed.
In order to enable an extension, you must <code class="b">use</code> it.
It's usage is again simple:
</p>
<code class="block">
<b>use</b> <i>globals</i>
</code>
<p>
Where <i>globals</i> is the extension you want to load. A list of recommended
extensions can be found in the Customization and Extensions chapter.
</p>

<h4>The include statement</h4>
<p>
The <code class="b">include</code> statement lets you add additional folders to
the template search path. See the Importation section for more details.
</p>

<h4>The import statement</h4>
<p>
The <code class="b">import</code> statement lets you import objects from one
namespace into the current one, as well as specifying the export rules.
See the Importation and Exportation sections for more details.
</p>

<h4>The export statements</h4>
<p>
The <code class="b">no export</code> statement specifies that the namespace 
does not allow exportation into it.
</p>
<p>
The <code class="b">require export</code> statement specifies that the 
namespace cannot be used directly, and instead requires the exportation of 
other templates and dictionaries to be usable.
</p>
<p>
See the Exportaion section for further details.
</p>

<h4>Syntax override statements</h4>
<p>
We're not going to cover these here. See the Overriding Syntax for details.
The list of core language syntax overrides statements is:
</p>
<p>
<code class="b">delimiters</code>, 
<code class="b">block</code>, 
<code class="b">dictblock</code>,
<code class="b">comment</code>,
<code class="b">condition</code>,
<code class="b">alias</code>,
<code class="b">note</code>,
<code class="b">positional</code>,
<code class="b">apply</code>,
<code class="b">negate</code>.
</p>


<h3 name="templates" id="templates">Templates</h3>
<p>
At the heart of any template engine, is the templates themselves.
Many template engines require that you have a single monolithic template
for each page or section of your application. 
One of the core concepts of Garden is instead using modular template
components to build your full templates. Not only does Garden support
nested templates, it relies on them for several aspects of the design itself
such as recursion and conditional sections.
</p>
<p>
In your namespace, you will likely have several template blocks, each
representing a "piece" of the template. In namespaces meant to represent
a single template, you should have a default template, with the same name
as the namespace itself. The other templates can be called from one another
easily.
</p>
<p>
If you have common components that are used in many different pages, you
can build a namespace to contain them, and call them from your other
templates (either by using the full namespace prefix, or by importing
the namespace.)
</p>

<h4>Template Block</h4>
<p>
A template block is defined using the following syntax:
</p>
<code class="block">
<i class="t">nameOfTemplate</i> (<i class="v">the</i>, <i class="v">parameters</i>, <i class="v">you</i>, <i class="v">require</i>) <i class="s">{{</i>
The content of the template.
<i class="s">}}</i>
</code>
<p>
Everything past the <i class="s">{{</i> symbol is the content of your template.
It will be parsed for template statements (see the Template Language chapter.)
The <i class="s">}}</i> symbol marks the end of the template block.
</p>
<p class="note">
The <i class="s">{{</i> and <i class="s">}}</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<p>
If the template block is on a single line, the whitespace at the beginning
and end of the block will be ignored, and no newline character will be put
at the end. Otherwise, it is assumed that all whitespace is to be preserved
"as is", including the newline at the end of the block.
</p>
<code class="block">
<i class="t">snippetBlock</i> () <i class="s">{{</i> Hello World <i class="s">}}</i>
</code>

<h4>Template Object</h4>
<p>
The Garden object's <code>get()</code> method should return an object
representing the template. This should have a <code>render()</code> method 
(or something similar) which you can pass the parameters in with. 
The parameters are all
named, so in the <i class="t">nameOfTemplate</i> example above, the
parameters you would need to pass
<code>the</code>,
<code>parameters</code>
<code>you</code>
<code>require</code>
as named parameters to the template's <code>render()</code> method.
</p>
<p>
All of the parameters in the signature must be passed to the template,
even if its value is undefined or false.
</p>


<h3 name="dicts" id="dicts">Dictionaries</h3>
<p>
Sometimes you may want to use certain repeated strings or values in
multiple places, and have the ability to pull variable keys out of
said data from your templates.
</p>
<p>
That's where dictionaries come in handy. They are a flat key/value based
system, where a string key can contain a string or numeric value. No nested
data structures are supported in the default dictionaries (there are however
extensions which can provide such things, such as the JSON Blocks extension.)
</p>
<p>
A dictionary block looks similar to a template block, except that it does not
have a signature, and uses different delimiters:
</p>
<code class="block">
<i class="d">myDict</i> <i class="s">{[</i>
  "<i>name</i>" : "Garden"
  "<i>desc</i>" : "A template language"
  "<i>ver</i>"  : "1"
<i class="s">]}</i>
</code>
<p class="note">
The <i class="s">{[</i> and <i class="s">]}</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<p>
You can then access the dictionary object as another variable in your template.
Each key will be an object member, so in the above call, you could have a
call to 
<code><i class="s">[[</i><i class="d">myDict</i>.<i class="v">desc</i><i class="s">]]</i></code> 
which would be replaced by the string "<em>A template language</em>".
</p>
<p class="note">
Currently you can only use dictionaries defined in the current namespace,
or those defined in any imported namespaces. Also, the only way to 
import namespaces dynamically, is progmatically using whatever API the 
Garden implementation offers.
In the Version 2 specification this will be addressed to allow for
dynamic namespace importing, and possibly direct referencing of dictionaries
(and other data, such as plugins) from other namespaces.
</p>


<h3 name="imports" id="imports">Importation</h3>
<p>
Sometimes its useful to create common namespaces, which contain templates
and dictionaries that can be shared between other namespaces. In the current
version of the specification, you can reference templates from other namespaces
from any other namespace, by using the full name of the template (including
the namespace.) However, as of version 1, there is no way to reference
dictionaries or other data from other namespaces (this is on the TODO list
for version 2.)
</p>
<p>
So in the cases where you want shared dictionaries, or in the cases where
you don't want to have to type the full name of a template, wouldn't it be
nice if you could just import the objects from one namespace into another one?
</p>
<p>
Well, you can. That's what the <code class="b">import</code> statement is for.
</p>
<h4>The import statement, in detail.</h4>
<p>
The <code class="b">import</code> statement does exactly what 
it says on the box, 
imports objects from one namespace into another. 
By default it imports templates and
dictionaries, however, it can import other data if requested. The basic
usage (importing the default objects) is simple:
</p>
<code class="block">
<b>import</b> "<i class="n">another/namespace</i>"
</code>
<p>
Yeah, that's it. You now have access to the templates and dictionaries from
<i class="n">another/namespace</i> in your current namespace. Pretty easy huh?
</p>
<p>
But that's not all. Say all of your templates are using a super custom
syntax, and you want to be able to share that syntax between all of your
namespaces without having to add all of those override statements to each
and every one of your namespace files. Well, that's where the 
<i class="f">:syntax</i> flag comes in handy:
</p>
<code class="block">
<b>import</b> "<i class="n">common</i>" <i class="f">:syntax</i>
</code>
<p>
Now, you've not only gained the templates and dictionaries from
<i class="n">common</i>, but you've imported the custom syntax rules too.
</p>
<p>
There are other flags that modify what you can import, such as the
<i class="f">:plugins</i> flag, but that's only applicable to the
Plugins extension, so we'll talk about it more when we get to that
section.
</p>
<p>
There is one other flag that the <code class="b">import</code> statement 
supports, <i class="f">:export</i>. This is a magic flag, in that it 
doesn't import anything extra, but instead changes how your namespace 
interacts with the namespace you've imported. 
See the Exportation section (coming up next) for more details on that.
</p>


<h3 name="exports" id="exports">Exportation</h3>
<p>
So, in the Importation section we introduced you to the
<code class="b">import</code> statement, and mentioned that it has a
<i class="f">:export</i> flag. Now we're going to cover how exporting
works, and how it can enable several object-oriented style methodologies
to your templates.
</p>
<p>
When you import the objects from one namespace into another, there is one
very important thing to remember: 
local rules override global ones. In other words, if you import
a <i class="n">common</i> namespace with a <i class="t">Page</i> template,
but then you define a <i class="t">Page</i> template in the local namespace,
the local template overrides the global one. 
</p>
<p>
The second thing that is important to note: normal importation is one way.
You import the templates from an external namespace into your local
namespace. The external namespace does not have access to any templates
in your local namespace.
</p>
<p>
What this means on a practical note is that if you do override the
<i class="t">Page</i> template, it will be used in your local namespace
whenever you make a <code><i class="s">[[</i><i class="t">Page()</i><i class="s">]]</i></code> call.
However, any imported templates from <i class="n">common</i> that make
a <code><i class="s">[[</i><i class="t">Page()</i><i class="s">]]</i></code> call, will be referring to the <i class="t">Page</i> template
within the <i class="n">common</i> namespace.
</p>
<p>
So, what if you want to override the version of <i class="t">Page</i> from
<i class="n">common</i> with the local version? Easy, add the
<i class="f">:export</i> flag to your <code class="b">import</code> statement.
</p>
<p>
All of the templates and dictionaries defined in your local class will be
exported to any namespaces that were imported using the 
<i class="f">:export</i> flag.
</p>
<p class="note">
Currently there is no way to specify which templates or dictionaries you
want exported, or to which namespaces. Any namespace that was imported using
the <i class="f">:export</i> flag will have <strong>all</strong> of the
local templates and dictionaries exported to it, overriding the versions
in the original namespace. More flexibility is being added in Version 2.
</p>
<p>
This is a powerful (and potentially dangerous) feature, allowing for a
great deal of flexibility in your template design. Because there are many
usage patterns for this, a few additional statements are available to
specify how your namespace handles exportation requests.
</p>
<h4>Requiring exportation</h4>
<p>
If your namespace requires templates and/or dictionaries from another
namespace in order to work (this could be useful to build a Role-like
template, which calls other templates not defined in the role class) you
can use the <code class="b">require export</code> statement in your
namespace. This namespace will refuse to be imported without the
<i class="f">export</i> flag in use.
</p>
<h4>Disallowing exportation</h4>
<p>
If your namespace is meant to be final, and you want to ensure that no
other namespace overrides its templates or dictionaries, you can specify
the <code class="b">no export</code> statement. When used, it will cause
a fatal error if an attempt to import it using the <i class="f">:export</i> 
flag is made.
</p>



<h2>Template Language</h2>
<h3 name="vars" id="vars">Variables</h3>
<p>
Describe basic variables here.
</p>


<h3 name="aliases" id="aliases">Local Aliases</h3>
<p>
Describe local variable aliases here.
</p>


<h3 name="methods" id="methods">Method calls</h3>
<p>
Describe variable method calls here.
</p>


<h3 name="nested" id="nested">Nested Templates</h3>
<p>
Describe nested template calls here.
</p>


<h3 name="apply" id="apply">Applying Templates</h3>
<p>
Describe template application (recursion) here.
</p>


<h3 name="conditional" id="conditional">Conditionals</h3>
<p>
Describe conditional statements here.
</p>


<h3 name="comments" id="comments">Comments</h3>
<p>
Describe how comments and notes work here.
</p>



<h2>Customization and Extensions</h2>
<h3 name="syntax" id="syntax">Overriding Syntax</h3>
<p>
Describe how to customize the syntax here.
</p>


<h3 name="globals" id="globals">Global Variables</h3>
<p>
Describe global variables here.
</p>


<h3 name="plugins" id="plugins">Plugins</h3>
<p>
Describe how plugins should work here.
</p>


<h3 name="json" id="json">JSON Blocks</h3>
<p>
Describe the JSON extension here.
</p>


<h3 name="ideas" id="ideas">Future ideas</h3>
<p>
Describe things that may show up later here, such as anonymous templates,
and template blocks that ignore leading and trailing whitespace.
</p>





<p id="footer"> 
<a href="index.html">Table of Contents</a> |
<a href="single_page.html">Single Page Version</a> |
<a href="https://github.com/supernovus/garden-spec/">Source</a>
</p>
</body>
</html>

