<html>
<head>
<title>Garden: Table of Contents</title>
<link rel="stylesheet" href="../style/main.css" />
<link rel="stylesheet" href="../style/docs.css" />
</head>
<body>
<h1>Garden -- A Functional Template Language</h1>
<h2>VERSION 1-DRAFT1</h2>
<h2>Table of Contents</h2>
<ul>
<li>Core Concepts
<ul>
<li>
<a href="#intro">Introduction</a>
</li>
<li>
<a href="#namespaces">Namespaces</a>
</li>
<li>
<a href="#statements">Statements</a>
</li>
<li>
<a href="#templates">Templates</a>
</li>
<li>
<a href="#dicts">Dictionaries</a>
</li>
<li>
<a href="#imports">Importation</a>
</li>
<li>
<a href="#exports">Exportation</a>
</li>

</ul>
</li>
<li>Template Language
<ul>
<li>
<a href="#vars">Variables</a>
</li>
<li>
<a href="#aliases">Local Aliases</a>
</li>
<li>
<a href="#nested">Nested Templates</a>
</li>
<li>
<a href="#apply">Recursive Templates</a>
</li>
<li>
<a href="#conditional">Conditionals</a>
</li>
<li>
<a href="#comments">Comments</a>
</li>

</ul>
</li>
<li>Customization and Extensions
<ul>
<li>
<a href="#syntax">Overriding Syntax</a>
</li>
<li>
<a href="#globals">Global Variables</a>
</li>
<li>
<a href="#plugins">Plugins</a>
</li>
<li>
<a href="#json">JSON Blocks</a>
</li>
<li>
<a href="#ideas">Future ideas</a>
</li>

</ul>
</li>

</ul>
<h2>Core Concepts</h2>
<h3 name="intro" id="intro">Introduction</h3>
<p>
Garden is a general-purpose functional template langauge. It doesn't
care what it's source textual format is and offers a great deal of flexibility 
without forcing too much application logic into your templates.
</p>
<p>
It offers a very different approach to recursion (looping) and conditional
sections of templates than most template engines, having been inspired by
StringTemplate (a Java-based functional template engine) and my own previous 
project: Flower (a Perl 6 XML Application Engine, with a TAL/METAL template
language included.)
</p>
<p>
One of the defining features of Garden is that it is very customizable.
It offers a flexible way to override certain syntax, to ensure the Garden
statements don't conflict with the textual content of your templates.
It also offers optional extensions that individual implementations may
choose to implement, and templates can request individually.
</p>
<p>
This specification defines the full language, as well as a few recommended
extensions. An implementation must implement all non-extension features
in order to comply with the specification.
</p>


<h3 name="namespaces" id="namespaces">Namespaces</h3>
<p>
In Garden, all templates, dictionaries, or localized settings are contained
in a namespace. Typically, each namespace is represented by a single file in 
a folder. The global Garden object can be given a list of folders to search 
for namespace files in. Individual namespaces can add additional folders to 
their search path. The search folders can use sub-folders to break up 
the namespaces better.
</p>
<p>
In the examples below, except where stated otherwise, it is assumed we have
a single search path, considing of the <i>./templates</i> folder.
</p>
<p>
The Garden object should have a <code>get()</code> method which returns a 
template to the application. 
Template names can be simple strings such as <i class="t">example</i>, 
or nested names such as <i class="t">common/example/mytemplate</i> 
When you call the <code>get()</code> method, or call a template from inside 
another template, you are always referring to the 
<em class="t">template</em> you want, not the <em class="n">namespace</em>
(although as the following will show, that can sometimes be the same name.)
</p>
<h4>Default Template</h4>
<p>
A namespace can have a default template. That is, a template with the same
name as the namespace itself. So for instance, if you have a namespace file
called <i class="n">./templates/example.tmpl</i> you could make a template 
within that  file called <i class="t">example</i> which would then be used 
as the default template. 
Thus from any other namespace, calling 
<code><u>[[</u><i class="t">example()</i><u>]]</u></code> would find 
the  <i class="n">example</i> namespace, and parse the 
<i class="t">example</i> template from within it.
</p>
<h4>Finding Templates</h4>
<p>
Okay, so if you use <code>get('common/example/mytemplate')</code> in the 
program, or 
<code><u>[[</u><i class="t">common/example/mytemplate()</i><u>]]</u></code> 
in a template, 
Garden needs to determine what you are looking for. 
In the case above, it could be one of two things:
</p>
<ol>
<li>The <i class="t">mytemplate</i> template in the <i class="n">common/example/mytemplate</i> namespace.</li>
<li>The <i class="t">mytemplate</i> template in the <i class="n">common/example</i> namespace.</li>
</ol>
<p>
Well, first we look for a namespace with the given name, so if
<i class="n">./templates/common/example/mytemplate.tmpl</i> exists, 
we will return the <i class="t">mytemplate</i> template from that namespace.
</p>
<p>
If it does not exist, then we see if 
<i class="n">./templates/common/example.tmpl</i> exists,
and if it does, we return the 
<i class="t">mytemplate</i> template from that namespace.
</p>
<p>
All of this is fairly simple so far, except in the case where you have more
than one search path. In that case, the above tests are repeated in order
for each path. More specific paths must be at the top of the search path
list. So, as an example, given your search folders are:
</p>
<ol>
<li><i>./templates/advanced</i></li>
<li><i>./templates/default</i></li>
</ol>
<p>
And you request <i class="t">common/example/mytemplate</i>, 
the following order will be used to find the namespace for 
the <i class="t">mytemplate</i> template:
</p>
<ol>
<li><i class="t">./templates/advanced/common/example/mytemplate.tmpl</i></li>
<li><i class="t">./templates/advanced/common/example.tmpl</i></li>
<li><i class="t">./templates/default/common/example/mytemplate.tmpl</i></li>
<li><i class="t">./templates/default/common/example.tmpl</i></li>
</ol>


<h3 name="statements" id="statements">Statements</h3>
<p>
In namespace files, only two things are parsed: statements and blocks.
We'll get to the various kinds of block later, but for now let's focus on
statements.
</p>
<p>
Before that however, a rather large and important rule. 
<strong>Any text not recognized as a statement or block, is ignored.</strong>
That's right, we don't barf, or bail, or go "what the hell is that", we just
ignore it. If it's not one of the known statements (either core, or extension),
and it's not a known block (again, core or extension), then we ignore it.
</p>
<p>
Okay, with that out of the way, let's move on to the known statements and
what they do. Note: the list below is only for Core statements. Any
statements added by extensions will be listed in the documentation for
that extension.
</p>

<h4>The version statement</h4>
<p>
Using the <code class="b">version</code> statement declares that your template
requires at least the specified version of the Garden specification in order
to be properly parsed. It's use is simple:
</p>
<code class="block">
<b>version</b> <i>1</i>
</code>
<p>
Where you replace the <i>1</i> with whatever version you are depending upon.
</p>
<p>
By specifying a version, the Garden implementation can enable certain
version-specific features, or changes to any default syntax. If you do
not specify a version statement, backwards compatibility with version 1 is
assumed. Additional features may be enabled with the lack of a version number,
but only if enabling them is backwards compatible with version 1 templates.
</p>

<h4>The use statement</h4>
<p>
Some features in Garden are optional. These are called Extensions.
There are two kinds of extensions: Recommended Extensions, and Implementation
Extensions. The first kind, as the name suggests, are recommended to be
available in every implementation, but that is not guaranteed.
In order to enable an extension, you must <code class="b">use</code> it.
It's usage is again simple:
</p>
<code class="block">
<b>use</b> <i>globals</i>
</code>
<p>
Where <i>globals</i> is the extension you want to load. A list of recommended
extensions can be found in the Customization and Extensions chapter.
</p>

<h4>The include statement</h4>
<p>
The <code class="b">include</code> statement lets you add additional folders to
the template search path. See the Importation section for more details.
</p>

<h4>The import statement</h4>
<p>
The <code class="b">import</code> statement lets you import objects from one
namespace into the current one, as well as specifying the export rules.
See the Importation and Exportation sections for more details.
</p>

<h4>The export statements</h4>
<p>
The <code class="b">no export</code> statement specifies that the namespace 
does not allow exportation into it.
</p>
<p>
The <code class="b">require export</code> statement specifies that the 
namespace cannot be used directly, and instead requires the exportation of 
other templates and dictionaries to be usable.
</p>
<p>
See the Exportaion section for further details.
</p>

<h4>Syntax override statements</h4>
<p>
We're not going to cover these here. See the Overriding Syntax for details.
The list of core language syntax overrides statements is:
</p>
<p>
<code class="b">delimiters</code>, 
<code class="b">block</code>, 
<code class="b">dictblock</code>,
<code class="b">comment</code>,
<code class="b">condition</code>,
<code class="b">alias</code>,
<code class="b">note</code>,
<code class="b">positional</code>,
<code class="b">apply</code>,
<code class="b">negate</code>.
</p>


<h3 name="templates" id="templates">Templates</h3>
<p>
At the heart of any template engine, is the templates themselves.
Many template engines require that you have a single monolithic template
for each page or section of your application. 
One of the core concepts of Garden is instead using modular template
components to build your full templates. Not only does Garden support
nested templates, it relies on them for several aspects of the design itself
such as recursion and conditional sections.
</p>
<p>
In your namespace, you will likely have several template blocks, each
representing a "piece" of the template. In namespaces meant to represent
a single template, you should have a default template, with the same name
as the namespace itself. The other templates can be called from one another
easily.
</p>
<p>
If you have common components that are used in many different pages, you
can build a namespace to contain them, and call them from your other
templates (either by using the full namespace prefix, or by importing
the namespace.)
</p>

<h4>Template Block</h4>
<p>
A template block is defined using the following syntax:
</p>
<code class="block">
<i class="t">nameOfTemplate</i> (<i class="v">the</i>, <i class="v">parameters</i>, <i class="v">you</i>, <i class="v">require</i>) <u>{{</u>
The content of the template.
<u>}}</u>
</code>
<p>
Everything past the <u>{{</u> symbol is the content of your template.
It will be parsed for template statements (see the Template Language chapter.)
The <u>}}</u> symbol marks the end of the template block.
</p>
<p class="note">
The <i class="s">{{</i> and <i class="s">}}</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<p>
If the template block is on a single line, the whitespace at the beginning
and end of the block will be ignored, and no newline character will be put
at the end. Otherwise, it is assumed that all whitespace is to be preserved
"as is", including the newline at the end of the block.
</p>
<code class="block">
<i class="t">snippetBlock</i> () <u>{{</u> Hello World <u>}}</u>
</code>

<h4>Template Object</h4>
<p>
The Garden object's <code>get()</code> method should return an object
representing the template. This should have a <code>render()</code> method 
(or something similar) which you can pass the parameters in with. 
The parameters are all
named, so in the <i class="t">nameOfTemplate</i> example above, the
parameters you would need to pass
<code>the</code>,
<code>parameters</code>
<code>you</code>
<code>require</code>
as named parameters to the template's <code>render()</code> method.
</p>
<p>
All of the parameters in the signature must be passed to the template,
even if its value is undefined or false.
</p>


<h3 name="dicts" id="dicts">Dictionaries</h3>
<p>
Sometimes you may want to use certain repeated strings or values in
multiple places, and have the ability to pull variable keys out of
said data from your templates.
</p>
<p>
That's where dictionaries come in handy. They are a flat key/value based
system, where a string key can contain a string or numeric value. No nested
data structures are supported in the default dictionaries (there are however
extensions which can provide such things, such as the JSON Blocks extension.)
</p>
<p>
A dictionary block looks similar to a template block, except that it does not
have a signature, and uses different delimiters:
</p>
<code class="block">
<i class="d">myDict</i> <u>{[</u>
  "<i>name</i>" : "Garden"
  "<i>desc</i>" : "A template language"
  "<i>ver</i>"  : "1"
<u>]}</u>
</code>
<p class="note">
The <i class="s">{[</i> and <i class="s">]}</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<p>
You can then access the dictionary object as another variable in your template.
Each key will be an object member, so in the above call, you could have a
call to 
<code><u>[[</u><i class="d">myDict</i>.<i class="v">desc</i><u>]]</u></code> 
which would be replaced by the string "<em>A template language</em>".
</p>
<p class="note">
Currently you can only use dictionaries defined in the current namespace,
or those defined in any imported namespaces. Also, the only way to 
import namespaces dynamically, is progmatically using whatever API the 
Garden implementation offers.
In the Version 2 specification this will be addressed to allow for
dynamic namespace importing, and possibly direct referencing of dictionaries
(and other data, such as plugins) from other namespaces.
</p>


<h3 name="imports" id="imports">Importation</h3>
<p>
Sometimes its useful to create common namespaces, which contain templates
and dictionaries that can be shared between other namespaces. In the current
version of the specification, you can reference templates from other namespaces
from any other namespace, by using the full name of the template (including
the namespace.) However, as of version 1, there is no way to reference
dictionaries or other data from other namespaces (this is on the TODO list
for version 2.)
</p>
<p>
So in the cases where you want shared dictionaries, or in the cases where
you don't want to have to type the full name of a template, wouldn't it be
nice if you could just import the objects from one namespace into another one?
</p>
<p>
Well, you can. That's what the <code class="b">import</code> statement is for.
</p>
<h4>The import statement, in detail.</h4>
<p>
The <code class="b">import</code> statement does exactly what 
it says on the box, 
imports objects from one namespace into another. 
By default it imports templates and
dictionaries, however, it can import other data if requested. The basic
usage (importing the default objects) is simple:
</p>
<code class="block">
<b>import</b> "<i class="n">another/namespace</i>"
</code>
<p>
Yeah, that's it. You now have access to the templates and dictionaries from
<i class="n">another/namespace</i> in your current namespace. Pretty easy huh?
</p>
<p>
But that's not all. Say all of your templates are using a super custom
syntax, and you want to be able to share that syntax between all of your
namespaces without having to add all of those override statements to each
and every one of your namespace files. Well, that's where the 
<i class="f">:syntax</i> flag comes in handy:
</p>
<code class="block">
<b>import</b> "<i class="n">common</i>" <i class="f">:syntax</i>
</code>
<p>
Now, you've not only gained the templates and dictionaries from
<i class="n">common</i>, but you've imported the custom syntax rules too.
</p>
<p>
There are other flags that modify what you can import, such as the
<i class="f">:plugins</i> flag, but that's only applicable to the
Plugins extension, so we'll talk about it more when we get to that
section.
</p>
<p>
There is one other flag that the <code class="b">import</code> statement 
supports, <i class="f">:export</i>. This is a magic flag, in that it 
doesn't import anything extra, but instead changes how your namespace 
interacts with the namespace you've imported. 
See the Exportation section (coming up next) for more details on that.
</p>


<h3 name="exports" id="exports">Exportation</h3>
<p>
So, in the Importation section we introduced you to the
<code class="b">import</code> statement, and mentioned that it has a
<i class="f">:export</i> flag. Now we're going to cover how exporting
works, and how it can enable several object-oriented style methodologies
to your templates.
</p>
<p>
When you import the objects from one namespace into another, there is one
very important thing to remember: 
local rules override global ones. In other words, if you import
a <i class="n">common</i> namespace with a <i class="t">Page</i> template,
but then you define a <i class="t">Page</i> template in the local namespace,
the local template overrides the global one. 
</p>
<p>
The second thing that is important to note: normal importation is one way.
You import the templates from an external namespace into your local
namespace. The external namespace does not have access to any templates
in your local namespace.
</p>
<p>
What this means on a practical note is that if you do override the
<i class="t">Page</i> template, it will be used in your local namespace
whenever you make a <code><u>[[</u><i class="t">Page()</i><u>]]</u></code> call.
However, any imported templates from <i class="n">common</i> that make
a <code><u>[[</u><i class="t">Page()</i><u>]]</u></code> call, will be referring to the <i class="t">Page</i> template
within the <i class="n">common</i> namespace.
</p>
<p>
So, what if you want to override the version of <i class="t">Page</i> from
<i class="n">common</i> with the local version? Easy, add the
<i class="f">:export</i> flag to your <code class="b">import</code> statement.
</p>
<p>
All of the templates and dictionaries defined in your local class will be
exported to any namespaces that were imported using the 
<i class="f">:export</i> flag.
</p>
<p class="note">
Currently there is no way to specify which templates or dictionaries you
want exported, or to which namespaces. Any namespace that was imported using
the <i class="f">:export</i> flag will have <strong>all</strong> of the
local templates and dictionaries exported to it, overriding the versions
in the original namespace. More flexibility is being added in Version 2.
</p>
<p>
This is a powerful (and potentially dangerous) feature, allowing for a
great deal of flexibility in your template design. Because there are many
usage patterns for this, a few additional statements are available to
specify how your namespace handles exportation requests.
</p>
<h4>Requiring exportation</h4>
<p>
If your namespace requires templates and/or dictionaries from another
namespace in order to work (this could be useful to build a Role-like
template, which calls other templates not defined in the role class) you
can use the <code class="b">require export</code> statement in your
namespace. This namespace will refuse to be imported without the
<i class="f">export</i> flag in use.
</p>
<h4>Disallowing exportation</h4>
<p>
If your namespace is meant to be final, and you want to ensure that no
other namespace overrides its templates or dictionaries, you can specify
the <code class="b">no export</code> statement. When used, it will cause
a fatal error if an attempt to import it using the <i class="f">:export</i> 
flag is made.
</p>



<h2>Template Language</h2>
<h3 name="vars" id="vars">Variables</h3>
<p>
The most fundamental part of any template language, is the ability to
replace specific identifiers with data provided by the application.
As these identifiers represent variable data, we call them variables.
</p>
<p>
In Garden, a variable can point to a number of different things, and the
order in which they are searched is important, as the first matching
variable overrides any with the same name in a later search location.
</p>
<ol>
<li>Variables defined within the template itself (aliases.)</li>
<li>Special variables specific to the current template context.</li>
<li>One of the named parameters sent to the template.</li>
<li>A definition within a Dictionary object.</li>
<li>Other variables added by extensions.</li>
</ol>
<p>
Typically a variable will contain a single value, such as a string, or
a number, but Garden also supports lists (arrays) and maps (hashes), although
they may be more useful in template application (see Recursive Templates.)
</p>
<p>
The basic usage for a variable containing a single value is:
</p>
<code class="block">
<u>[[</u><i class="v">variablename</i><u>]]</u>
</code>
<p class="note">
The <i class="s">[[</i> and <i class="s">]]</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<p>
This will replace <i class="v">variablename</i> with whatever content
that variable contains.
</p>
<h4>Simple list expansion</h4>
<p>
If you have a simple list variable, and wish to just join the elements
together with a separator, that's also easy using the <i class="f">sep</i>
option:
</p>
<code class="block">
<u>[[</u><i class="v">arrayvar</i>; <i class="f">sep</i>=", "<u>]]</u>
</code>
<p>
In this example, all of the elements of the <i class="v">arrayvar</i>
variable will be joined together with ", ". For more advanced use of
lists/arrays and maps/hashes, see the Recursive Templates section.
</p>
<h4>Variable members</h4>
<p>
If a variable is a map/hash or object, it can contain named <em>members</em>,
which you can access with a dot.
</p>
<code class="block">
<u>[[</u><i class="v">objvar.member.nested</i><u>]]</u>
</code>
<h4>Variable method calls</h4>
<p>
Some members may actually be method calls, in which case you need to be
able to specify parameters for the methods. Member method call parameters can 
be either positional or named:
</p>
<code class="block">
<u>[[</u><i class="v">objvar.myMethod</i>(<i class="v">posparam</i>, <i class="v">namedparam</i>=<i class="v">localvar</i>)<u>]]</u>
</code>
<p>
In the above example, the <code>myMethod()</code> method on the
<i class="v">objvar</i> object will be called with its first positional
parameter being set to the value of the <i class="v">posparam</i>
variable, and a named parameter of <i class="v">namedparam</i> being
set to the value of the <i class="v">localvar</i> variable.
</p>
<p>
The parameters can also be the output of templates. See the Nested Templates
section for more details on how to call a template.
</p>
<h4>Indirect member access</h4>
<p>
Sometimes you want to access a member based on a variable. In this case
you will use indirect member access.
</p>
<code class="block">
<u>[[</u><i class="v">objvar</i>.<u>`</u><i class="v">membername</i><u>`</u><u>]]</u>
</code>
<p>
In this example, you have a variable called 
<i class="v">membername</i> which will
contain the name of the member you want to get from the
<i class="v">objvar</i> variable. So if <i class="v">membername</i> was
set to "<em>id</em>", then the <i class="v">objvar.id</i> member would be
returned.
</p>
<p>
Indirect members can be nested within large path statements such as:
</p>
<code class="block">
<u>[[</u><i class="v">objvar</i>.<u>`</u><i class="v">what</i><u>`</u>.<i class="var">name</i><u>]]</u>
</code>
<p class="note">
The <i class="s">`</i> and <i class="s">`</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>



<h3 name="aliases" id="aliases">Local Aliases</h3>
<p>
Sometimes you'll want to make local variables that apply to your current
template, to make it easy to refer to what otherwise could be a long
nested variable expression. This is simple using aliases.
</p>
<code class="block">
<u>[[</u><i class="v">aliasname</i><u>=</u><i class="v">some.large</i>.<u>`</u>nested<u>`</u>.statement(param)<u>]]</u>
Okay, now we're going to refer to the <u>[[</u><i class="v">aliasname</i><u>]]</u>
variable from now on.
</code>
<p>
By assigning a local alias variable to a long expression, it makes it easy to
reuse elsewhere.
</p>
<p>
The above example showed assigning an alias to a nested variable expression,
but it is also possible to assign an alias to the output of a template:
</p>
<code class="block">
<u>[[</u><i class="v">content</i><u>=</u><i class="t">myTemplate()</i><u>]]</u>
Now <i class="v">content</i> contains the output from the
<i class="t">myTemplate</i> template.
</code>
<p>
See the Nested Templates section for more information on how to make
template calls.
</p>
<p class="note">
The <i class="s">=</i> symbol is customizable. See the Overriding Syntax section for more details.
</p>



<h3 name="nested" id="nested">Nested Templates</h3>
<p>
A core principle in Garden is to split up templates into modular sections.
Instead of having one large monolithic template, it's easier to make little
template snippets, and compose them together into your desired template.
</p>
<p>
The template snippets can be used in a few ways. Here we're going to describe
how to make direct calls to those templates.
</p>
<h4>A template with no parameters</h4>
<p>
You may have little common snippets that take no parameters, if that is
the case, you can call the template very easily:
</p>
<code class="block">
<u>[[</u><i class="t">templateName</i>()<u>]]</u>
</code>
<h4>A template with parameters</h4>
<p>
However, more often than not, templates have parameters, and you need
to be able to specify those parameters in the template you are calling.
To do this, we specify the parameters in the template call signature.
</p>
<code class="block">
  <i class="t">firstTemplate</i> (<i class="v">company</i>, <i class="v">user</i>) <u>{{</u>
  Here we will call another template: <u>[[</u><i class="t">secondTemplate</i>(<i class="v">company</i>, <i class="v">name</i>=<i class="v">user.name</i>)<u>]]</u>
  <u>}}</u>
  <i class="t">secondTemplate</i> (<i class="v">company</i>, <i class="v">name</i>) <u>{{</u>
  Yes, <u>[[</u><i class="v">name</i><u>]]</u> works for <u>[[</u><i class="v">company</i><u>]]</u>.
  <u>}}</u>
</code>
<p>
Here our <i class="t">firstTemplate</i> is making a call to
<i class="t">secondTemplate</i>, passing the <i class="v">company</i>
variable through directly and passing the <i class="v">user.name</i>
variable through as <i class="v">name</i> which is what 
<i class="t">secondTemplate</i> is looking for.
</p>
<p>
Using named parameters when possible is recommended. If you don't use named
parameters, then how what you pass is determined to be a parameter will
depend on context. If you pass a variable with the same name as a parameter
in the template you are calling, it will be assumed to be that parameter,
regardless of order. If it isn't, it will be assumed to be a positional
parameter. This can be used with literals to create easy template sections.
For instance:
</p>
<code class="block">
<i class="t">myTemplate</i> (<i class="v">name</i>) <u>{{</u>
Yeah, so <u>[[</u>name<u>]]</u> said: <u>[[</u>b(Hello)<u>]]</u>
<u>}}</u>

<i class="t">text</i> (<i class="v">y</i>) <u>{{</u> &lt;strong&gt;<u>[[</u>text<u>]]</u>&lt;/strong&gt; <u>}}</u>

<u>/*</u> <tt>Given a name of Bob, will result in:
   Yeah, so Bob said: &lt;strong&gt;Hello&lt;/strong&gt;</tt> <u>*/</u>
</code>
<p class="note">
Using literal text as parameters rather than variables, has several
limitations, and does not handle text with spaces in it. 
The use of dictionaries is recommended instead of literal text.
</p>


<h3 name="apply" id="apply">Recursive Templates</h3>
<p>
Most template languages support looping constructs similar to programming
languages. These looping constructs are used to apply sections of the
template to every item in a list.
</p>
<p>
In Garden, instead of specifying a block of your template as the portion to
be recursed over, we specify another template to apply to the list, as well
as the positional parameter(s) that each item in the list will be assigned to.
How many parameters depends on if the variable is a flat list (array) or
a map (hash).
</p>
<p>
As an example of applying a template to a simple flat list of user items:
</p>
<code class="block">
<i class="t">testTemplate</i> (<i class="v">userlist</i>) <u>{{</u>
Okay, we have the following users:
<u>[[</u><i class="v">userlist</i><u>:</u><i class="t">userItem</i>(<u>*</u><i class="v">user</i>)<u>]]</u>
<u>}}</u>

<i class="t">userItem</i> (<i class="v">user</i>) <u>{{</u>
 * <u>[[</u><i class="v">user.name</i><u>]]</u>
<u>}}</u>
</code>
<p class="note">
The <i class="s">:</i> and <i class="s">*</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<p>
Alternatively, say instead of the flat list of user items, you had a map/hash
where the key was the username, and the value was their real name. In that
case you could apply a template like this:
</p>
<code class="block">
<i class="t">hashTest</i> (<i class="v">userhash</i>) <u>{{</u>
We have the following users:
<u>[[</u><i class="v">userhash</i><u>:</u><i class="t">userList</i>(<u>*</u><i class="v">id</i>, <u>*</u><i class="v">name</i>)<u>]]</u>
<u>}}</u>

<i class="t">userList</i> (<i class="v">id</i>, <i class="v">name</i>) <u>{{</u>
 * <u>[[</u><i class="v">id</i><u>]]</u>: <u>[[</u><i class="v">name</i><u>]]</u>
<u>}}</u>
</code>
<p>
Additional parameters can be sent in the template call, by using the standard
parameter passing syntax. Only the special positional parameters use the
<u>*</u> prefix. Flat lists (arrays) require one positional parameter.
Maps (hashes) require one positional parameter, and support two parameters:
the first will be assigned to the key, and the second to the value.
</p>
<h4>Separator</h4>
<p>
As seen previously in the Variables section, if you want a specific separator
between the items, you can specify a <i class="f">sep</i> option.
</p>
<code class="block">
<u>[[</u><i class="v">users</i><u>:</u><i class="t">userList</i>(<u>*</u><i class="v">user</i>); <i class="f">sep</i>=", "<u>]]</u>
</code>
<h4>The Repeat Object</h4>
<p>
One magic feature now shown yet, is the repeat object that is created
automatically when you use template application. The repeat object is
always created with the same name as the template it applies to. It offers
the following members:
</p>
<dl>
<dt><i class="v">index</i></dt>
<dd>The current iteration number (starts from 0)</dd>
<dt><i class="v">count</i></dt>
<dd>The number of items in the list we are recursing</dd>
<dt><i class="v">length</i></dt>
<dd>An alias to count.</dd>
<dt><i class="v">number</i></dt>
<dd>The current item number (starts from 1). This will always be
the same as <i class="v">index</i> + 1.</dd>
<dt><i class="v">start</i></dt>
<dd>Returns true if this is the first item.</dd>
<dt><i class="v">end</i></dt>
<dd>Returns true if this is the last item.</dd>
<dt><i class="v">odd</i></dt>
<dd>Returns true if the <i class="v">number</i> is odd.</dd>
<dt><i class="v">even</i></dt>
<dd>Returns true if the <i class="v">number</i> is even.</dd>
<dt><i class="v">every</i>(<i class="v">num</i>)</dt>
<dd>Returns true every <i class="v">num</i> number of iterations.</dd>
<dt><i class="v">skip</i>(<i class="v">num</i>)</dt>
<dd>Returns false every <i class="v">num</i> number of iterations.</dd>
<dt><i class="v">lt</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is less than <i class="v">num</i></dd>
<dt><i class="v">gt</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is greater than <i class="v">num</i></dd>
<dt><i class="v">lte</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is less than or equal to <i class="v">num</i></dd>
<dt><i class="v">gte</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is greater than or equal to <i class="v">num</i></dd>
<dt><i class="v">eq</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is equal to <i class="v">num</i></dd>
<dt><i class="v">ne</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is not equal to <i class="v">num</i></dd>
<dt><i class="v">repeatEvery</i>(<i class="v">num</i>)</dt>
<dd>Returns true on the first item, and every <i class="v">num</i> iterations.</dd>
</dl>
<p>
A simple example of the use of the repeat object:
</p>
<code class="block">
<i class="t">myTemplate</i> (<i class="v">rows</i>) <u>{{</u>
<u>[[</u><i class="v">rows</i><u>:</u><i class="t">showRow</i>(<u>*</u><i class="v">row</i>)<u>]]</u>
<u>}}</u>

<i class="t">showRow</i> (<i class="v">row</i>) <u>{{</u>
 <u>[[</u><i class="v">showRow.number</i><u>]]</u>.) <u>[[</u><i class="v">row</i><u>]]</u>
<u>}}</u>
</code>
<p>
See the Conditionals section for an example of how to use some of the
repeat object's members that return boolean values.
</p>


<h3 name="conditional" id="conditional">Conditionals</h3>
<p>
Often there are portions of your template that show only show up under
certain circumstances. Many template languages have complex constructs
for creating conditional sections, with tags like if, elseif, else, and
all sorts of comparison operators. Garden takes a different approach.
</p>
<p>
First of all, we don't have any comparison operators. It's conditional
statements check for truth or falseness of a single variable.
Your application controller should handle any special logic to create the
variables for testing against.
</p>
<p>
That said, Garden does support elseif and else statements, in its own way.
</p>
<p>
First thing to note, like recursion, conditional statements work
by calling (applying) a template based on the results of the condition.
</p>

<h4>A simple condition</h4>
<p>
The following shows a simple condition, which will call a template if
the variable is true, and won't call the template if it is false.
</p>
<code class="block">
<u>[[</u><u>?</u><i class="v">vartotest</i><u>:</u><i class="t">trueTemplate()</i><u>]]</u>
</code>
<p>
The context is simple, if <i class="v">vartotest</i> is a true value, which
means it's defined, not 0, and not equal to its own name (i.e. 
<i class="v">vartotest</i> will be false if it is returned as <em>vartotest</em>), then the
<i class="t">trueTemplate()</i> will be called. Like any other template call,
you can pass whatever parameters you need to it.
</p>
<p class="note">
The <i class="s">?</i> and <i class="s">:</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<h4>An else statement</h4>
<p>
Often not only do you want to apply a statement if the value is true, but
you want to apply a different statement if the value is false.
</p>
<code class="block">
<u>[[</u><u>?</u><i class="v">vartotest</i><u>:</u><i class="t">trueTemplate()</i><u>;</u><i class="t">falseTemplate()</i><u>]]</u>
</code>
<p>
So like the first example, we test to see if <i class="v">vartotest</i> is true. If it is,
like before, we show <i class="t">trueTemplate()</i>. The difference is, this time if it is not
true, we show <i class="t">falseTemplate()</i> instead.
</p>
<p class="note">
The <i class="s">;</i> symbol is customizable. See the Overriding Syntax section for more details.
</p>

<h4>An elseif statement</h4>
<p>
Sometimes you want to test two different variables, if the first is true,
apply a template, if not, then if the second is true, apply a template.
If neither are true, then if we have an third template, apply it instead.
</p>
<code class="block">
<u>[[</u><u>?</u><i class="v">var1</i><u>;</u><i class="v">var2</i><u>:</u><i class="t">templateOne()</i><u>;</u><i class="t">templateTwo()</i><u>;</u><i class="t">falseTemplate()</i><u>]]</u>
</code>
<p>
If <i class="v">var1</i> is true, we apply <i class="t">templateOne()</i>. Otherwise, if <i class="v">var2</i> is true
we apply <i class="t">templateTwo()</i>. Finally, if neither are true, we apply <i class="t">falseTemplate()</i>.
You can leave off the final template if you don't want anything to be
applied in the case that none of the variables are true. You can put as many
variables as you want between the separator (<u>;</u>), as long as you have
at least that many templates after the apply symbol (<u>:</u>). You can always
supply one extra template to be used if none of the variables are true.
</p>
<h4>Negative Conditions</h4>
<p>
Sometimes instead of testing to see if something is true, you may want to
see if it is false instead. This is possible by prefixing the condition
variable with the negation symbol (<u>!</u>).
</p>
<code class="block">
<u>[[</u><u>?</u><i class="v">var1</i><u>;</u><u>!</u><i class="v">var2</i><u>:</u><i class="t">templateOne()</i><u>;</u><i class="t">templateTwo()</i><u>;</u><i class="t">falseTemplate()</i><u>]]</u>
</code>
<p>
This is similar to the elseif example, except that instead of testing to see
if <i class="v">var2</i> is true, it tests to see if it is false. So the only way the
<i class="t">falseTemplate()</i> template will ever be called is if <i class="v">var1</i> is false and <i class="v">var2</i> is
true.
</p>

<h4>Chained Comparisions</h4>

<p class="note">
This version of Garden has no support for comparison operators, or
chained (complex) tests. So there's no way to do things like
<code class="block">
if ((var1 &gt; var2) and (var2 &lt; var3)) { show_this_template; }
</code>
without putting the comparison logic in the controller. I'm not really sure
if this is something that belongs in the template language. At this point
I've left it out, as something that is best handled in the controller.
In a future version, I may add an extension to allow something 
that allows a limited
form of chained comparison operators into the template language itself.
If I add it, and what form it will take is yet undecided.
</p>


<h3 name="comments" id="comments">Comments</h3>
<p>
The ability to make notes in your templates, either for documentation
or to add a private TODO note for yourself, is very useful.
Sometimes you even want to be able to comment out an entire section of your
template while testing things. Both of these abilities are possible in
Garden, with a configurable syntax too boot.
</p>
<p class="note">
All of the comment related syntax below applies inside template and
dictionary blocks.
You can use them outside of blocks, but it's not really necessary, as
any text outside a block that isn't a statement, or a block definition,
is ignored.
</p>
<h4>Notes</h4>
<p>
A note is a quick comment, that ends with a newline character.
In Garden, the note prefix must either be the first character of the
line, or have white space in front of it to be recognized.
</p>
<code class="block">
<i class="t">myTemplate</i> () <u>{{</u>
Hello World <u>##</u> <tt>Everything after the <u>##</u> marks is a note comment.</tt>
<u>##</u> <tt>This line in its entirety is a note comment.</tt>
This is not a comment.
<u>}}</u>
</code>
<p class="note">
The <i class="s">##</i> symbol is customizable. See the Overriding Syntax section for more details.
</p>

<h4>Comment Blocks</h4>
<p>
If you want to comment out an entire block, you can do so with special
comment symbols:
</p>
<code class="block">
<i class="t">myTemplate</i> () <u>{{</u>
Hello <u>/*</u> <tt>Everything past that symbol is a comment.
Including this line.
And this text.</tt> <u>*/</u> World. (This is not a comment.)
<u>}}</u>
</code>
<p class="note">
The <i class="s">/*</i> and <i class="s">*/</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>




<h2>Customization and Extensions</h2>
<h3 name="syntax" id="syntax">Overriding Syntax</h3>
<p>
So, in all of the documentation up to now, you've probably seen notes
saying that certain symbols are overridable. This is to make it so that
your templates can customize what characters are considered <em>syntax</em>
versus <em>content</em>. The default have been designed to be fairly 
non-conflicting with most markup languages, but I can't claim to forsee every
possible use of Garden, so making it as flexible as possible was a primary
design principle.
</p>

<h4>Template Block Markers</h4>
<p>
The <code class="b">block</code> statement is used to override
the <u>{{</u> and <u>}}</u> symbols:
</p>
<code class="block">
<b>block</b> "<u>&lt;&lt;&lt;</u>", "<u>&gt;&gt;&gt;</u>"

<i class="t">myTemplate</i> (name) <u>&lt;&lt;&lt;</u>
Hello <u>[[</u>name<u>]]</u>
<u>&gt;&gt;&gt;</u>
</code>

<h4>Dictionary Block Markers</h4>
<p>
The <code class="b">dictblock</code> statement is used to override
the <u>{[</u> and <u>]}</u> symbols:
</p>
<code class="block">
<b>dictblock</b> "<u>[[[</u>", "<u>]]]</u>"

<i class="d">myDict</i> <u>[[[</u>
 "<i>name</i>" : "Tim"
 "<i>job</i>"  : "Programmer"
<u>]]]</u>
</code>

<h4>Template Statements Markers</h4>
<p>
The <code class="b">delimiters</code> statement is used to override 
the <u>[[</u> and <u>]]</u> symbols:
</p>
<code class="block">
<b>delimiters</b> "<u>$</u>", "<u>$</u>"

<i class="t">myTemplate</i> (name) <u>{{</u>
Hello <u>$</u>name<u>$</u>
<u>}}</u>
</code>

<h4>Note Symbol</h4>
<p>
The <code class="b">note</code> statement is used to override
the <u>##</u> symbol:
</p>
<code class="block">
<b>note</b> "<u>//</u>"

<i class="t">myTemplate</i> () <u>{{</u>
Hello World <u>//</u> This is a note-style comment.
<u>}}</u>
</code>

<h4>Comment Block Markers</h4>
<p>
The <code class="b">comment</code> statement is used to override
the <u>/*</u> and <u>*/</u> symbols:
</p>
<code class="block">
<b>comment</b> "<u>&lt;--</u>", "<u>--&gt;</u>"

<i class="t">myTemplate</i> () <u>{{</u>
<u>&lt;--</u> <tt>This is a long
multilined comment
that goes on for a while.</tt> <u>--&gt;</u>
Hello World
<u>}}</u>
</code>

<h4>The Apply Symbol</h4>
<p>
The apply symbol ( <u>:</u> ) is used both in conditional statement, and in
recursive template application. The <code class="b">apply</code> statement
is used to override it:
</p>
<code class="block">
<b>apply</b> "<u>-&gt;</u>"

<i class="t">myTemplate</i> (alist) <u>{{</u>
The list:
<u>[[</u>alist<u>-&gt;</u>listTemplate(*item)<u>]]</u>
<u>}}</u>
</code>

<h4>Conditional statement marker and separator</h4>
<p>
In conditional statements, there are three symbols used, the
conditional marker: ( <u>?</u> ), the separator for conditions and templates: 
( <u>;</u> ), and the apply symbol: ( <u>:</u> ). We've already seen how
to override the apply symbol, so we're going to skip it in this example.
The <code class="b">condition</code> statement allows you to override
the first two:
</p>
<code class="block">
<b>condition</b> "<u>if </u>" "<u>|</u>"

<i class="t">myTemplate</i> (<i class="v">yes</i>, <i class="v">maybe</i>) <u>{{</u>
Are we ready? <u>[[</u><u>if </u><i class="v">yes</i><u>|</u><i class="v">maybe</i><u>:</u><i class="t">yesTemplate()</i><u>|</u><i class="t">maybeTemplate()</i><u>|</u><i class="t">noTemplate()</i><u>]]</u>
<u>}}</u>
</code>

<h4>Alias Symbol</h4>
<p>
The <code class="b">alias</code> statement is used to override
the alias symbol ( <u>=</u> ):
</p>
<code class="block">
<b>alias</b> "<u>@</u>"

<i class="t">myTemplate</i> (<i class="v">obj</i>) <u>{{</u>
<u>[[</u><i class="v">var</i><u>@</u><i class="v">obj.nested.member</i><u>]]</u>
Hello <u>[[</u><i class="v">var</i><u>]]</u>
<u>}}</u>
</code>

<h4>Recursive Positional Parameters</h4>
<p>
The special recursive parameters all start with the ( <u>*</u> ) prefix.
This can be override using the <code class="b">positional</code> statement:
</p>
<code class="block">
<b>positional</b> "<u>&amp;</u>"

<i class="t">myTemplate</i> (<i class="v">myarray</i>) <u>{{</u>
List:
<u>[[</u><i class="v">myarray</i><u>:</u><i class="t">listItem</i>(<u>&amp;</u><i class="v">item</i>)<u>]]</u>
<u>}}</u>

<i class="t">listItem</i> (<i class="v">item</i>) <u>{{</u>
* <u>[[</u><i class="v">item</i><u>]]</u>
<u>}}</u>
</code>

<h4>Condition Negation Prefix</h4>
<p>
To negate a condition in a conditional statement, you use the negation
prefix ( <u>!</u> ). This can be overriden using the <code class="b">negate</code>
statement:
</p>
<code class="block">
<b>negate</b> "<u>-</u>"

<i class="t">myTemplate</i> (<i class="v">mytest</i>) <u>{{</u>
<u>[[</u><u>?</u><u>-</u><i class="v">mytest</i><u>:</u><i class="t">falseTemplate</i><u>;</u><i class="t">trueTemplate</i><u>]]</u>
<u>}}</u>
</code>

<h4>Other Overrides</h4>
<p>
Extensions may add additional override statements. They will be listed
in the description of the extension, and are only available if you use
the extension.
</p>



<h3 name="globals" id="globals">Global Variables</h3>
<p>
Sometimes you want to be able to access certain variables
from any template, without having to pass them around. That's where
the <em>Global Variables</em> extension comes into play.
</p>
<p>
Global variables give you special variables that are accessible from any
template, in any namespace that declares it requires them. The variables
must be initialized in the Garden object prior to loading a template from
a namespace that requires them.
</p>
<p>
Enabling global variables is as simple as adding the 
<code><b>use globals</b></code> statement to your namespace file.
After that, you need to declare which global variables your namespace
expects. Then any attempt to use templates from that namespace from a
Garden instance that has not declared the required global variables, will fail.
Declaring these is done with the <code class="b">global</code> statement:
</p>
<code class="block">
<b>global</b> <i>var1</i>
<b>global</b> <i>var2</i>
</code>
<p class="note">
There is no fixed standard for how the programming API will populate the
global variables, and that is left up to the implementations.
</p>


<h3 name="plugins" id="plugins">Plugins</h3>
<p>
Inspired by the plugins functionality from Flower, which in turn was inspired
by the Petal::Utils library from Perl 5, this extension offers the ability to
add plugins to Garden.
</p>
<p>
The exact nature of the plugins is not described, except that they should
receive a reference to the Garden object itself, and a reference to the
namespace object which they were loaded from.
</p>
<p>
You can enable the plugins extension by declaring 
<code class="b">use plugins</code> in your namespace file. Then after that
statement, add <code class="b">plugin</code> statements for each of the plugins you want
to load:
</p>
<code class="block">
<b>plugin</b> "<i class="v">varname</i>" "<i class="v">pluginname</i>"
</code>
<p>
You will be able to call methods on the plugin by referecing its variable name.
</p>
<code class="block">
<u>[[</u><i class="v">varname</i>.<i>methodName</i>(<i class="v">param</i>)`<u>]]</u>
</code>
<h4>Addition to the import statement</h4>
<p>
By declaring the <code class="b">use plugins</code> statement, a new 
<i class="f">:plugins</i> flag will be added to the 
<code class="b">import</code> statement, which requests that namespace
plugins be imported as well.
</p>


<h3 name="json" id="json">JSON Blocks</h3>
<p>
Sometimes you need more than a flat Dictionary, and that's exactly what
JSON can offer. The JSON extension allows for special blocks to be parsed
as a JSON object, and referenced the same way as you would a dictionary or
nested variable.
</p>
<p>
In implementation supporting the JSON extension, you can enable it using the
<code class="b">use json</code> statement. After that, you can define JSON
blocks using the default delimiters <u>{<</u> and <u>>}</u> or redefine them using
the <code class="b">json</code> statement.
</p>
<code class="block">
<b>use json</b>

<b>json</b> "<i>(((</i>", "<i>)))</i>"

<i class="d">MyDict</i> <u>(((</u>
  {
    "hello" : "World",
    "this"  : [ "is", "a "test " ],
    "we"    : { "support" : "nested", "structures" : 1 }
  }
<u>)))</u>

`tmpl(myTemplate) () <u>{{</u>
Hello <u>[[</u><i class="d">MyDict</i>.<i class="v">hello</i><u>]]</u>.
<u>}}</u>
</code>
<p>
I'm not sure how useful this extension is in real use, and like any extension,
it's up to individual implementations whether or not to support it.
</p>


<h3 name="ideas" id="ideas">Future ideas</h3>
<p>
There are several ideas I have planned for future versions of Garden.
Some of them may show up sooner than others. Many require further research and
planning before they are even ready to write a spec for, let alone implement.
Implementations may choose to implement some of them as implementation specific
extensions, just taking into account that a future Garden spec will probably
make an <em>official</em> way of doing them.
</p>

<h4>Dynamic statements via Globals</h4>
<p>
Basically the idea behind this is, to make the <code class="b">import</code> and
<code class="b">include</code> statements more flexible by allowing them to use global
variables as their values. So a template could do something like:
</p>
<code class="block">
<b>version 2</b>
<b>use globals</b>
<b>global</b> <i class="v">usersettings</i>
<b>include</b> <i class="v">usersettings.langdir</i>
<b>import</b> <i class="v">usersettings.language</i>
</code>
<p>
As this depends on the Globals extension, it would only be enabled
if you have enabled that extension (if that wasn't obvious.)
</p>
<p>
This will definitely make it into Version 2.
</p>

<h4>Block Options</h4>
<p>
The ability to set options on blocks would allow several
other abilities to be easier to implement. I'm not sure what form this would
take, but (for the sake of a mockup) imagine:
</p>
<code class="block">
`tmpl(myTemplate) (<i class="v">myvar</i>) <i class="f">:export</i>(<i class="v">def</i>) <i class="f">:oneline</i> <u>{{</u>
Blah blah blah
<u>]]</u>
</code>
<p>
So in our example above, the <i class="f">:export</i> 
flag (with a <i class="v">def</i> parameter) and the
<i class="f">:oneline</i> flag, would be added to the block options.
Block options would be able to be used by other core features and extensions
for various purposes (see below for some examples.)
</p>
<p>This will definitely make it into Version 2</p>

<h4>Whitespace rules for template blocks</h4>
<p>
Currently there are two forms of template blocks. One that preserves all
whitespace, and one that cuts leading and following whitespace out. The only
thing is, to use the latter one, you have to have the entire template 
definition on a single line. Wouldn't it be nice if you could specify a longer
template snippet, that you really want on one line in the finished results,
on one line?
</p>
<p>
Inspired by StringTemplate (one of the two major inspirations for Garden in the
first place), an option to make this possible, as well as a few other options
for whitespace handling, are planned to be implemented using the Block options.
</p>
<p>
This will definitely make it into Version 2</p>
</p>

<h4>Referencing of external dictionaries</h4>
<p>
Currently you can reference external templates by using the namespace
prefix. This does not work with dictionaries. This should be rectified.
</p>
<p>
This is very likely to make it into Version 2.
</p>

<h4>Flexible export rules</h4>
<p>
Currently the Exportation is very much an all-or-nothing approach.
Basically, the general idea of this would be to make it so that you could
subscribe to certain exports.
</p>
<p>
For backwards compatibility and simplicity, existing <code class="b">import</code>
statements using the <i class="f">:export</i> flag would work the same as
they do now (all templates and dictionaries would be exported, overriding
versions that are the same.)
</p>
<p>
In the new version though, you could specify an export group in the
<code class="b">import</code> statement, and only templates and/or dictionaries with a
<i class="f">:export</i> block option matching the export group would
be exported to that namespace. The exact details aren't worked out yet,
but it would add a great deal more flexibility to what gets exported.
</p>
<p>
On the flip side, adding a <i class="f">:noreplace</i> block option to a
block would make it so that it could not be overridden with an exported
version (and any attempt to do so would result in a failure message.)
</p>
<p>
Some form of this is likely to make it into Version 2.
</p>

<h4>In-template Array Creation</h4>
<p>
Another feature inspired by StringTemplate. The ability to create arrays
within template definitions themselves. Not sure what form it will take yet.
</p>
<p>
Some form of this is likely to make it into Version 2.
</p>

<h4>Parsed Blocks</h4>
<p>
Another feature using block options, these would look similar to dictionary
blocks, except that their contents would be passed to a Plugin to be parsed.
</p>
<p>
You would need to enable the plugins extension, load an appropriate plugin,
and set the block option on the block to parse. The usefulness of this is
still in question.
</p>
<p>
Some form of this will likely make it into a future version.
</p>

<h4>Anonymous templates</h4>
<p>
Currently, in recusive template calls and conditional template calls, you
need to specify a template name to call. StringTemplate offers the ability
to create one-off anonymous templates that can be used instead.
</p>
<p>
This may be useful, but personally I'm not sure how much so, and if it's worth
the extra parsing power that would be required to do it.
</p>
<p>
This may show up in a future version, as either a core feature or an
extension. It may have to be a core feature, due to it requiring a grammar
modification. This is definitely an undecided idea.
</p>






<p id="footer"> 
<a href="index.html">Table of Contents</a> |
<a href="single_page.html">Single Page Version</a> |
<a href="https://github.com/supernovus/garden-spec/">Source</a>
</p>
</body>
</html>

