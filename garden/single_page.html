<html>
<head>
<title>Garden: Table of Contents</title>
<link rel="stylesheet" href="../style/main.css" />
<link rel="stylesheet" href="../style/docs.css" />
</head>
<body>
<h1>Garden -- A Functional Template Language</h1>
<h2>VERSION 1-PREDRAFT5</h2>
<h2>Table of Contents</h2>
<ul>
<li>Core Concepts
<ul>
<li>
<a href="#intro">Introduction</a>
</li>
<li>
<a href="#namespaces">Namespaces</a>
</li>
<li>
<a href="#statements">Statements</a>
</li>
<li>
<a href="#templates">Templates</a>
</li>
<li>
<a href="#dicts">Dictionaries</a>
</li>
<li>
<a href="#imports">Importation</a>
</li>
<li>
<a href="#exports">Exportation</a>
</li>

</ul>
</li>
<li>Template Language
<ul>
<li>
<a href="#vars">Variables</a>
</li>
<li>
<a href="#aliases">Local Aliases</a>
</li>
<li>
<a href="#nested">Nested Templates</a>
</li>
<li>
<a href="#apply">Recursive Templates</a>
</li>
<li>
<a href="#conditional">Conditionals</a>
</li>
<li>
<a href="#comments">Comments</a>
</li>

</ul>
</li>
<li>Customization and Extensions
<ul>
<li>
<a href="#syntax">Overriding Syntax</a>
</li>
<li>
<a href="#globals">Global Variables</a>
</li>
<li>
<a href="#plugins">Plugins</a>
</li>
<li>
<a href="#json">JSON Blocks</a>
</li>
<li>
<a href="#ideas">Future ideas</a>
</li>

</ul>
</li>

</ul>
<h2>Core Concepts</h2>
<h3 name="intro" id="intro">Introduction</h3>
<p>
Garden is a general-purpose functional template langauge. It doesn't
care what it's source textual format is and offers a great deal of flexibility 
without forcing too much application logic into your templates.
</p>
<p>
It offers a very different approach to recursion (looping) and conditional
sections of templates than most template engines, having been inspired by
StringTemplate (a Java-based functional template engine) and my own previous 
project: Flower (a Perl 6 XML Application Engine, with a TAL/METAL template
language included.)
</p>
<p>
One of the defining features of Garden is that it is very customizable.
It offers a flexible way to override certain syntax, to ensure the Garden
statements don't conflict with the textual content of your templates.
It also offers optional extensions that individual implementations may
choose to implement, and templates can request individually.
</p>
<p>
This specification defines the full language, as well as a few recommended
extensions. An implementation must implement all non-extension features
in order to comply with the specification.
</p>


<h3 name="namespaces" id="namespaces">Namespaces</h3>
<p>
In Garden, all templates, dictionaries, or localized settings are contained
in a namespace. Typically, each namespace is represented by a single file in 
a folder. The global Garden object can be given a list of folders to search 
for namespace files in. Individual namespaces can add additional folders to 
their search path. The search folders can use sub-folders to break up 
the namespaces better.
</p>
<p>
In the examples below, except where stated otherwise, it is assumed we have
a single search path, considing of the <i>./templates</i> folder.
</p>
<p>
The Garden object should have a <code>get()</code> method which returns a 
template to the application. 
Template names can be simple strings such as <i class="t">example</i>, 
or nested names such as <i class="t">common/example/mytemplate</i> 
When you call the <code>get()</code> method, or call a template from inside 
another template, you are always referring to the 
<em class="t">template</em> you want, not the <em class="n">namespace</em>
(although as the following will show, that can sometimes be the same name.)
</p>
<h4>Default Template</h4>
<p>
A namespace can have a default template. That is, a template with the same
name as the namespace itself. So for instance, if you have a namespace file
called <i class="n">./templates/example.tmpl</i> you could make a template 
within that  file called <i class="t">example</i> which would then be used 
as the default template. 
Thus from any other namespace, calling 
<code><u>[[</u><i class="t">example()</i><u>]]</u></code> would find 
the  <i class="n">example</i> namespace, and parse the 
<i class="t">example</i> template from within it.
</p>
<h4>Finding Templates</h4>
<p>
Okay, so if you use <code>get('common/example/mytemplate')</code> in the 
program, or 
<code><u>[[</u><i class="t">common/example/mytemplate()</i><u>]]</u></code> 
in a template, 
Garden needs to determine what you are looking for. 
In the case above, it could be one of two things:
</p>
<ol>
<li>The <i class="t">mytemplate</i> template in the <i class="n">common/example/mytemplate</i> namespace.</li>
<li>The <i class="t">mytemplate</i> template in the <i class="n">common/example</i> namespace.</li>
</ol>
<p>
Well, first we look for a namespace with the given name, so if
<i class="n">./templates/common/example/mytemplate.tmpl</i> exists, 
we will return the <i class="t">mytemplate</i> template from that namespace.
</p>
<p>
If it does not exist, then we see if 
<i class="n">./templates/common/example.tmpl</i> exists,
and if it does, we return the 
<i class="t">mytemplate</i> template from that namespace.
</p>
<p>
All of this is fairly simple so far, except in the case where you have more
than one search path. In that case, the above tests are repeated in order
for each path. More specific paths must be at the top of the search path
list. So, as an example, given your search folders are:
</p>
<ol>
<li><i>./templates/advanced</i></li>
<li><i>./templates/default</i></li>
</ol>
<p>
And you request <i class="t">common/example/mytemplate</i>, 
the following order will be used to find the namespace for 
the <i class="t">mytemplate</i> template:
</p>
<ol>
<li><i class="t">./templates/advanced/common/example/mytemplate.tmpl</i></li>
<li><i class="t">./templates/advanced/common/example.tmpl</i></li>
<li><i class="t">./templates/default/common/example/mytemplate.tmpl</i></li>
<li><i class="t">./templates/default/common/example.tmpl</i></li>
</ol>


<h3 name="statements" id="statements">Statements</h3>
<p>
In namespace files, only two things are parsed: statements and blocks.
We'll get to the various kinds of block later, but for now let's focus on
statements.
</p>
<p>
Before that however, a rather large and important rule. 
<strong>Any text not recognized as a statement or block, is ignored.</strong>
That's right, we don't barf, or bail, or go "what the hell is that", we just
ignore it. If it's not one of the known statements (either core, or extension),
and it's not a known block (again, core or extension), then we ignore it.
</p>
<p>
Okay, with that out of the way, let's move on to the known statements and
what they do. Note: the list below is only for Core statements. Any
statements added by extensions will be listed in the documentation for
that extension.
</p>

<h4>The version statement</h4>
<p>
Using the <code class="b">version</code> statement declares that your template
requires at least the specified version of the Garden specification in order
to be properly parsed. It's use is simple:
</p>
<code class="block">
<b>version</b> <i>1</i>
</code>
<p>
Where you replace the <i>1</i> with whatever version you are depending upon.
</p>
<p>
By specifying a version, the Garden implementation can enable certain
version-specific features, or changes to any default syntax. If you do
not specify a version statement, backwards compatibility with version 1 is
assumed. Additional features may be enabled with the lack of a version number,
but only if enabling them is backwards compatible with version 1 templates.
</p>

<h4>The use statement</h4>
<p>
Some features in Garden are optional. These are called Extensions.
There are two kinds of extensions: Recommended Extensions, and Implementation
Extensions. The first kind, as the name suggests, are recommended to be
available in every implementation, but that is not guaranteed.
In order to enable an extension, you must <code class="b">use</code> it.
It's usage is again simple:
</p>
<code class="block">
<b>use</b> <i>globals</i>
</code>
<p>
Where <i>globals</i> is the extension you want to load. A list of recommended
extensions can be found in the Customization and Extensions chapter.
</p>

<h4>The include statement</h4>
<p>
The <code class="b">include</code> statement lets you add additional folders to
the template search path. See the Importation section for more details.
</p>

<h4>The import statement</h4>
<p>
The <code class="b">import</code> statement lets you import objects from one
namespace into the current one, as well as specifying the export rules.
See the Importation and Exportation sections for more details.
</p>

<h4>The export statements</h4>
<p>
The <code class="b">no export</code> statement specifies that the namespace 
does not allow exportation into it.
</p>
<p>
The <code class="b">require export</code> statement specifies that the 
namespace cannot be used directly, and instead requires the exportation of 
other templates and dictionaries to be usable.
</p>
<p>
See the Exportaion section for further details.
</p>

<h4>Syntax override statements</h4>
<p>
We're not going to cover these here. See the Overriding Syntax for details.
The list of core language syntax overrides statements is:
</p>
<p>
<code class="b">delimiters</code>, 
<code class="b">block</code>, 
<code class="b">dictblock</code>,
<code class="b">comment</code>,
<code class="b">condition</code>,
<code class="b">alias</code>,
<code class="b">note</code>,
<code class="b">positional</code>,
<code class="b">apply</code>,
<code class="b">negate</code>.
</p>


<h3 name="templates" id="templates">Templates</h3>
<p>
At the heart of any template engine, is the templates themselves.
Many template engines require that you have a single monolithic template
for each page or section of your application. 
One of the core concepts of Garden is instead using modular template
components to build your full templates. Not only does Garden support
nested templates, it relies on them for several aspects of the design itself
such as recursion and conditional sections.
</p>
<p>
In your namespace, you will likely have several template blocks, each
representing a "piece" of the template. In namespaces meant to represent
a single template, you should have a default template, with the same name
as the namespace itself. The other templates can be called from one another
easily.
</p>
<p>
If you have common components that are used in many different pages, you
can build a namespace to contain them, and call them from your other
templates (either by using the full namespace prefix, or by importing
the namespace.)
</p>

<h4>Template Block</h4>
<p>
A template block is defined using the following syntax:
</p>
<code class="block">
<i class="t">nameOfTemplate</i> (<i class="v">the</i>, <i class="v">parameters</i>, <i class="v">you</i>, <i class="v">require</i>) <u>{{</u>
The content of the template.
<u>}}</u>
</code>
<p>
Everything past the <u>{{</u> symbol is the content of your template.
It will be parsed for template statements (see the Template Language chapter.)
The <u>}}</u> symbol marks the end of the template block.
</p>
<p class="note">
The <i class="s">{{</i> and <i class="s">}}</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<p>
If the template block is on a single line, the whitespace at the beginning
and end of the block will be ignored, and no newline character will be put
at the end. Otherwise, it is assumed that all whitespace is to be preserved
"as is", including the newline at the end of the block.
</p>
<code class="block">
<i class="t">snippetBlock</i> () <u>{{</u> Hello World <u>}}</u>
</code>

<h4>Template Object</h4>
<p>
The Garden object's <code>get()</code> method should return an object
representing the template. This should have a <code>render()</code> method 
(or something similar) which you can pass the parameters in with. 
The parameters are all
named, so in the <i class="t">nameOfTemplate</i> example above, the
parameters you would need to pass
<code>the</code>,
<code>parameters</code>
<code>you</code>
<code>require</code>
as named parameters to the template's <code>render()</code> method.
</p>
<p>
All of the parameters in the signature must be passed to the template,
even if its value is undefined or false.
</p>


<h3 name="dicts" id="dicts">Dictionaries</h3>
<p>
Sometimes you may want to use certain repeated strings or values in
multiple places, and have the ability to pull variable keys out of
said data from your templates.
</p>
<p>
That's where dictionaries come in handy. They are a flat key/value based
system, where a string key can contain a string or numeric value. No nested
data structures are supported in the default dictionaries (there are however
extensions which can provide such things, such as the JSON Blocks extension.)
</p>
<p>
A dictionary block looks similar to a template block, except that it does not
have a signature, and uses different delimiters:
</p>
<code class="block">
<i class="d">myDict</i> <u>{[</u>
  "<i>name</i>" : "Garden"
  "<i>desc</i>" : "A template language"
  "<i>ver</i>"  : "1"
<u>]}</u>
</code>
<p class="note">
The <i class="s">{[</i> and <i class="s">]}</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<p>
You can then access the dictionary object as another variable in your template.
Each key will be an object member, so in the above call, you could have a
call to 
<code><u>[[</u><i class="d">myDict</i>.<i class="v">desc</i><u>]]</u></code> 
which would be replaced by the string "<em>A template language</em>".
</p>
<p class="note">
Currently you can only use dictionaries defined in the current namespace,
or those defined in any imported namespaces. Also, the only way to 
import namespaces dynamically, is progmatically using whatever API the 
Garden implementation offers.
In the Version 2 specification this will be addressed to allow for
dynamic namespace importing, and possibly direct referencing of dictionaries
(and other data, such as plugins) from other namespaces.
</p>


<h3 name="imports" id="imports">Importation</h3>
<p>
Sometimes its useful to create common namespaces, which contain templates
and dictionaries that can be shared between other namespaces. In the current
version of the specification, you can reference templates from other namespaces
from any other namespace, by using the full name of the template (including
the namespace.) However, as of version 1, there is no way to reference
dictionaries or other data from other namespaces (this is on the TODO list
for version 2.)
</p>
<p>
So in the cases where you want shared dictionaries, or in the cases where
you don't want to have to type the full name of a template, wouldn't it be
nice if you could just import the objects from one namespace into another one?
</p>
<p>
Well, you can. That's what the <code class="b">import</code> statement is for.
</p>
<h4>The import statement, in detail.</h4>
<p>
The <code class="b">import</code> statement does exactly what 
it says on the box, 
imports objects from one namespace into another. 
By default it imports templates and
dictionaries, however, it can import other data if requested. The basic
usage (importing the default objects) is simple:
</p>
<code class="block">
<b>import</b> "<i class="n">another/namespace</i>"
</code>
<p>
Yeah, that's it. You now have access to the templates and dictionaries from
<i class="n">another/namespace</i> in your current namespace. Pretty easy huh?
</p>
<p>
But that's not all. Say all of your templates are using a super custom
syntax, and you want to be able to share that syntax between all of your
namespaces without having to add all of those override statements to each
and every one of your namespace files. Well, that's where the 
<i class="f">:syntax</i> flag comes in handy:
</p>
<code class="block">
<b>import</b> "<i class="n">common</i>" <i class="f">:syntax</i>
</code>
<p>
Now, you've not only gained the templates and dictionaries from
<i class="n">common</i>, but you've imported the custom syntax rules too.
</p>
<p>
There are other flags that modify what you can import, such as the
<i class="f">:plugins</i> flag, but that's only applicable to the
Plugins extension, so we'll talk about it more when we get to that
section.
</p>
<p>
There is one other flag that the <code class="b">import</code> statement 
supports, <i class="f">:export</i>. This is a magic flag, in that it 
doesn't import anything extra, but instead changes how your namespace 
interacts with the namespace you've imported. 
See the Exportation section (coming up next) for more details on that.
</p>


<h3 name="exports" id="exports">Exportation</h3>
<p>
So, in the Importation section we introduced you to the
<code class="b">import</code> statement, and mentioned that it has a
<i class="f">:export</i> flag. Now we're going to cover how exporting
works, and how it can enable several object-oriented style methodologies
to your templates.
</p>
<p>
When you import the objects from one namespace into another, there is one
very important thing to remember: 
local rules override global ones. In other words, if you import
a <i class="n">common</i> namespace with a <i class="t">Page</i> template,
but then you define a <i class="t">Page</i> template in the local namespace,
the local template overrides the global one. 
</p>
<p>
The second thing that is important to note: normal importation is one way.
You import the templates from an external namespace into your local
namespace. The external namespace does not have access to any templates
in your local namespace.
</p>
<p>
What this means on a practical note is that if you do override the
<i class="t">Page</i> template, it will be used in your local namespace
whenever you make a <code><u>[[</u><i class="t">Page()</i><u>]]</u></code> call.
However, any imported templates from <i class="n">common</i> that make
a <code><u>[[</u><i class="t">Page()</i><u>]]</u></code> call, will be referring to the <i class="t">Page</i> template
within the <i class="n">common</i> namespace.
</p>
<p>
So, what if you want to override the version of <i class="t">Page</i> from
<i class="n">common</i> with the local version? Easy, add the
<i class="f">:export</i> flag to your <code class="b">import</code> statement.
</p>
<p>
All of the templates and dictionaries defined in your local class will be
exported to any namespaces that were imported using the 
<i class="f">:export</i> flag.
</p>
<p class="note">
Currently there is no way to specify which templates or dictionaries you
want exported, or to which namespaces. Any namespace that was imported using
the <i class="f">:export</i> flag will have <strong>all</strong> of the
local templates and dictionaries exported to it, overriding the versions
in the original namespace. More flexibility is being added in Version 2.
</p>
<p>
This is a powerful (and potentially dangerous) feature, allowing for a
great deal of flexibility in your template design. Because there are many
usage patterns for this, a few additional statements are available to
specify how your namespace handles exportation requests.
</p>
<h4>Requiring exportation</h4>
<p>
If your namespace requires templates and/or dictionaries from another
namespace in order to work (this could be useful to build a Role-like
template, which calls other templates not defined in the role class) you
can use the <code class="b">require export</code> statement in your
namespace. This namespace will refuse to be imported without the
<i class="f">export</i> flag in use.
</p>
<h4>Disallowing exportation</h4>
<p>
If your namespace is meant to be final, and you want to ensure that no
other namespace overrides its templates or dictionaries, you can specify
the <code class="b">no export</code> statement. When used, it will cause
a fatal error if an attempt to import it using the <i class="f">:export</i> 
flag is made.
</p>



<h2>Template Language</h2>
<h3 name="vars" id="vars">Variables</h3>
<p>
The most fundamental part of any template language, is the ability to
replace specific identifiers with data provided by the application.
As these identifiers represent variable data, we call them variables.
</p>
<p>
In Garden, a variable can point to a number of different things, and the
order in which they are searched is important, as the first matching
variable overrides any with the same name in a later search location.
</p>
<ol>
<li>Variables defined within the template itself (aliases.)</li>
<li>Special variables specific to the current template context.</li>
<li>One of the named parameters sent to the template.</li>
<li>A definition within a Dictionary object.</li>
<li>Other variables added by extensions.</li>
</ol>
<p>
Typically a variable will contain a single value, such as a string, or
a number, but Garden also supports lists (arrays) and maps (hashes), although
they may be more useful in template application (see Recursive Templates.)
</p>
<p>
The basic usage for a variable containing a single value is:
</p>
<code class="block">
<u>[[</u><i class="v">variablename</i><u>]]</u>
</code>
<p class="note">
The <i class="s">[[</i> and <i class="s">]]</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<p>
This will replace <i class="v">variablename</i> with whatever content
that variable contains.
</p>
<h4>Simple list expansion</h4>
<p>
If you have a simple list variable, and wish to just join the elements
together with a separator, that's also easy using the <i class="f">sep</i>
option:
</p>
<code class="block">
<u>[[</u><i class="v">arrayvar</i>; <i class="f">sep</i>=", "<u>]]</u>
</code>
<p>
In this example, all of the elements of the <i class="v">arrayvar</i>
variable will be joined together with ", ". For more advanced use of
lists/arrays and maps/hashes, see the Recursive Templates section.
</p>
<h4>Variable members</h4>
<p>
If a variable is a map/hash or object, it can contain named <em>members</em>,
which you can access with a dot.
</p>
<code class="block">
<u>[[</u><i class="v">objvar.member.nested</i><u>]]</u>
</code>
<h4>Variable method calls</h4>
<p>
Some members may actually be method calls, in which case you need to be
able to specify parameters for the methods. Member method call parameters can 
be either positional or named:
</p>
<code class="block">
<u>[[</u><i class="v">objvar.myMethod</i>(<i class="v">posparam</i>, <i class="v">namedparam</i>=<i class="v">localvar</i>)<u>]]</u>
</code>
<p>
In the above example, the <code>myMethod()</code> method on the
<i class="v">objvar</i> object will be called with its first positional
parameter being set to the value of the <i class="v">posparam</i>
variable, and a named parameter of <i class="v">namedparam</i> being
set to the value of the <i class="v">localvar</i> variable.
</p>
<p>
The parameters can also be the output of templates. See the Nested Templates
section for more details on how to call a template.
</p>
<h4>Indirect member access</h4>
<p>
Sometimes you want to access a member based on a variable. In this case
you will use indirect member access.
</p>
<code class="block">
<u>[[</u><i class="v">objvar</i>.<u>`</u><i class="v">membername</i><u>`</u><u>]]</u>
</code>
<p>
In this example, you have a variable called 
<i class="v">membername</i> which will
contain the name of the member you want to get from the
<i class="v">objvar</i> variable. So if <i class="v">membername</i> was
set to "<em>id</em>", then the <i class="v">objvar.id</i> member would be
returned.
</p>
<p>
Indirect members can be nested within large path statements such as:
</p>
<code class="block">
<u>[[</u><i class="v">objvar</i>.<u>`</u><i class="v">what</i><u>`</u>.<i class="var">name</i><u>]]</u>
</code>
<p class="note">
The <i class="s">`</i> and <i class="s">`</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>



<h3 name="aliases" id="aliases">Local Aliases</h3>
<p>
Sometimes you'll want to make local variables that apply to your current
template, to make it easy to refer to what otherwise could be a long
nested variable expression. This is simple using aliases.
</p>
<code class="block">
<u>[[</u><i class="v">aliasname</i><u>=</u><i class="v">some.large</i>.<u>`</u>nested<u>`</u>.statement(param)<u>]]</u>
Okay, now we're going to refer to the <u>[[</u><i class="v">aliasname</i><u>]]</u>
variable from now on.
</code>
<p>
By assigning a local alias variable to a long expression, it makes it easy to
reuse elsewhere.
</p>
<p>
The above example showed assigning an alias to a nested variable expression,
but it is also possible to assign an alias to the output of a template:
</p>
<code class="block">
<u>[[</u><i class="v">content</i><u>=</u><i class="t">myTemplate()</i><u>]]</u>
Now <i class="v">content</i> contains the output from the
<i class="t">myTemplate</i> template.
</code>
<p>
See the Nested Templates section for more information on how to make
template calls.
</p>
<p class="note">
The <i class="s">=</i> symbol is customizable. See the Overriding Syntax section for more details.
</p>



<h3 name="nested" id="nested">Nested Templates</h3>
<p>
A core principle in Garden is to split up templates into modular sections.
Instead of having one large monolithic template, it's easier to make little
template snippets, and compose them together into your desired template.
</p>
<p>
The template snippets can be used in a few ways. Here we're going to describe
how to make direct calls to those templates.
</p>
<h4>A template with no parameters</h4>
<p>
You may have little common snippets that take no parameters, if that is
the case, you can call the template very easily:
</p>
<code class="block">
<u>[[</u><i class="t">templateName</i>()<u>]]</u>
</code>
<h4>A template with parameters</h4>
<p>
However, more often than not, templates have parameters, and you need
to be able to specify those parameters in the template you are calling.
To do this, we specify the parameters in the template call signature.
</p>
<code class="block">
  <i class="t">firstTemplate</i> (<i class="v">company</i>, <i class="v">user</i>) <u>{{</u>
  Here we will call another template: <u>[[</u><i class="t">secondTemplate</i>(<i class="v">company</i>, <i class="v">name</i>=<i class="v">user.name</i>)<u>]]</u>
  <u>}}</u>
  <i class="t">secondTemplate</i> (<i class="v">company</i>, <i class="v">name</i>) <u>{{</u>
  Yes, <u>[[</u><i class="v">name</i><u>]]</u> works for <u>[[</u><i class="v">company</i><u>]]</u>.
  <u>}}</u>
</code>
<p>
Here our <i class="t">firstTemplate</i> is making a call to
<i class="t">secondTemplate</i>, passing the <i class="v">company</i>
variable through directly (as long as two templates have variables of
the same name, this is possible) and passing the <i class="v">user.name</i>
variable through as <i class="v">name</i> which is what 
<i class="t">secondTemplate</i> is looking for.
</p>


<h3 name="apply" id="apply">Recursive Templates</h3>
<p>
Most template languages support looping constructs similar to programming
languages. These looping constructs are used to apply sections of the
template to every item in a list.
</p>
<p>
In Garden, instead of specifying a block of your template as the portion to
be recursed over, we specify another template to apply to the list, as well
as the positional parameter(s) that each item in the list will be assigned to.
How many parameters depends on if the variable is a flat list (array) or
a map (hash).
</p>
<p>
As an example of applying a template to a simple flat list of user items:
</p>
<code class="block">
<i class="t">testTemplate</i> (<i class="v">userlist</i>) <u>{{</u>
Okay, we have the following users:
<u>[[</u><i class="v">userlist</i><u>:</u><i class="t">userItem</i>(<u>*</u><i class="v">user</i>)<u>]]</u>
<u>}}</u>

<i class="t">userItem</i> (<i class="v">user</i>) <u>{{</u>
 * <u>[[</u><i class="v">user.name</i><u>]]</u>
<u>}}</u>
</code>
<p class="note">
The <i class="s">:</i> and <i class="s">*</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<p>
Alternatively, say instead of the flat list of user items, you had a map/hash
where the key was the username, and the value was their real name. In that
case you could apply a template like this:
</p>
<code class="block">
<i class="t">hashTest</i> (<i class="v">userhash</i>) <u>{{</u>
We have the following users:
<u>[[</u><i class="v">userhash</i><u>:</u><i class="t">userList</i>(<u>*</u><i class="v">id</i>, <u>*</u><i class="v">name</i>)<u>]]</u>
<u>}}</u>

<i class="t">userList</i> (<i class="v">id</i>, <i class="v">name</i>) <u>{{</u>
 * <u>[[</u><i class="v">id</i><u>]]</u>: <u>[[</u><i class="v">name</i><u>]]</u>
<u>}}</u>
</code>
<p>
Additional parameters can be sent in the template call, by using the standard
parameter passing syntax. Only the special positional parameters use the
<u>*</u> prefix. Flat lists (arrays) require one positional parameter.
Maps (hashes) require one positional parameter, and support two parameters:
the first will be assigned to the key, and the second to the value.
</p>
<h4>Separator</h4>
<p>
As seen previously in the Variables section, if you want a specific separator
between the items, you can specify a <i class="f">sep</i> option.
</p>
<code class="block">
<u>[[</u><i class="v">users</i><u>:</u><i class="t">userList</i>(<u>*</u><i class="v">user</i>); <i class="f">sep</i>=", "<u>]]</u>
</code>
<h4>The Repeat Object</h4>
<p>
One magic feature now shown yet, is the repeat object that is created
automatically when you use template application. The repeat object is
always created with the same name as the template it applies to. It offers
the following members:
</p>
<dl>
<dt><i class="v">index</i></dt>
<dd>The current iteration number (starts from 0)</dd>
<dt><i class="v">count</i></dt>
<dd>The number of items in the list we are recursing</dd>
<dt><i class="v">length</i></dt>
<dd>An alias to count.</dd>
<dt><i class="v">number</i></dt>
<dd>The current item number (starts from 1). This will always be
the same as <i class="v">index</i> + 1.</dd>
<dt><i class="v">start</i></dt>
<dd>Returns true if this is the first item.</dd>
<dt><i class="v">end</i></dt>
<dd>Returns true if this is the last item.</dd>
<dt><i class="v">odd</i></dt>
<dd>Returns true if the <i class="v">number</i> is odd.</dd>
<dt><i class="v">even</i></dt>
<dd>Returns true if the <i class="v">number</i> is even.</dd>
<dt><i class="v">every</i>(<i class="v">num</i>)</dt>
<dd>Returns true every <i class="v">num</i> number of iterations.</dd>
<dt><i class="v">skip</i>(<i class="v">num</i>)</dt>
<dd>Returns false every <i class="v">num</i> number of iterations.</dd>
<dt><i class="v">lt</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is less than <i class="v">num</i></dd>
<dt><i class="v">gt</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is greater than <i class="v">num</i></dd>
<dt><i class="v">lte</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is less than or equal to <i class="v">num</i></dd>
<dt><i class="v">gte</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is greater than or equal to <i class="v">num</i></dd>
<dt><i class="v">eq</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is equal to <i class="v">num</i></dd>
<dt><i class="v">ne</i>(<i class="v">num</i>)</dt>
<dd>Returns true if <i class="v">number</i> is not equal to <i class="v">num</i></dd>
<dt><i class="v">repeatEvery</i>(<i class="v">num</i>)</dt>
<dd>Returns true on the first item, and every <i class="v">num</i> iterations.</dd>
</dl>
<p>
A simple example of the use of the repeat object:
</p>
<code class="block">
<i class="t">myTemplate</i> (<i class="v">rows</i>) <u>{{</u>
<u>[[</u><i class="v">rows</i><u>:</u><i class="t">showRow</i>(<u>*</u><i class="v">row</i>)<u>]]</u>
<u>}}</u>

<i class="t">showRow</i> (<i class="v">row</i>) <u>{{</u>
 <u>[[</u><i class="v">showRow.number</i><u>]]</u>.) <u>[[</u><i class="v">row</i><u>]]</u>
<u>}}</u>
</code>
<p>
See the Conditionals section for an example of how to use some of the
repeat object's members that return boolean values.
</p>


<h3 name="conditional" id="conditional">Conditionals</h3>
<p>
Often there are portions of your template that show only show up under
certain circumstances. Many template languages have complex constructs
for creating conditional sections, with tags like if, elseif, else, and
all sorts of comparison operators. Garden takes a different approach.
</p>
<p>
First of all, we don't have any comparison operators. It's conditional
statements check for truth or falseness of a single variable.
Your application controller should handle any special logic to create the
variables for testing against.
</p>
<p>
That said, Garden does support elseif and else statements, in its own way.
</p>
<p>
First thing to note, like recursion, conditional statements work
by calling (applying) a template based on the results of the condition.
</p>

<h4>A simple condition</h4>
<p>
The following shows a simple condition, which will call a template if
the variable is true, and won't call the template if it is false.
</p>
<code class="block">
<u>[[</u><u>?</u><i class="v">vartotest</i><u>:</u><i class="t">trueTemplate()</i><u>]]</u>
</code>
<p>
The context is simple, if <i class="v">vartotest</i> is a true value, which
means it's defined, not 0, and not equal to its own name (i.e. 
<i class="v">vartotest</i> will be false if it is returned as <em>vartotest</em>), then the
<i class="t">trueTemplate()</i> will be called. Like any other template call,
you can pass whatever parameters you need to it.
</p>
<p class="note">
The <i class="s">?</i> and <i class="s">:</i> symbols are
customizable. See the Overriding Syntax section for more details. 
</p>

<h4>An else statement</h4>
<p>
Often not only do you want to apply a statement if the value is true, but
you want to apply a different statement if the value is false.
</p>
<code class="block">
<u>[[</u><u>?</u><i class="v">vartotest</i><u>:</u><i class="t">trueTemplate()</i><u>;</u><i class="t">falseTemplate()</i><u>]]</u>
</code>
<p>
So like the first example, we test to see if <i class="v">vartotest</i> is true. If it is,
like before, we show <i class="t">trueTemplate()</i>. The difference is, this time if it is not
true, we show <i class="t">falseTemplate()</i> instead.
</p>
<p class="note">
The <i class="s">;</i> symbol is customizable. See the Overriding Syntax section for more details.
</p>

<h4>An elseif statement</h4>
<p>
Sometimes you want to test two different variables, if the first is true,
apply a template, if not, then if the second is true, apply a template.
If neither are true, then if we have an third template, apply it instead.
</p>
<code class="block">
<u>[[</u><u>?</u><i class="v">var1</i><u>;</u><i class="v">var2</i><u>:</u><i class="t">templateOne()</i><u>;</u><i class="t">templateTwo()</i><u>;</u><i class="t">falseTemplate()</i><u>]]</u>
</code>
<p>
If <i class="v">var1</i> is true, we apply <i class="t">templateOne()</i>. Otherwise, if <i class="v">var2</i> is true
we apply <i class="t">templateTwo()</i>. Finally, if neither are true, we apply <i class="t">falseTemplate()</i>.
You can leave off the final template if you don't want anything to be
applied in the case that none of the variables are true. You can put as many
variables as you want between the separator (<u>;</u>), as long as you have
at least that many templates after the apply symbol (<u>:</u>). You can always
supply one extra template to be used if none of the variables are true.
</p>
<p class="note">
This version of Garden has no support for comparison operators. In a future
version, I may add an extension to allow something that allows a limited
form of chained comparison operators into the template language itself.
What form it will take is yet undecided.
</p>


<h3 name="comments" id="comments">Comments</h3>
<p>
Describe how comments and notes work here.
</p>



<h2>Customization and Extensions</h2>
<h3 name="syntax" id="syntax">Overriding Syntax</h3>
<p>
Describe how to customize the syntax here.
</p>


<h3 name="globals" id="globals">Global Variables</h3>
<p>
Describe global variables here.
</p>


<h3 name="plugins" id="plugins">Plugins</h3>
<p>
Describe how plugins should work here.
</p>


<h3 name="json" id="json">JSON Blocks</h3>
<p>
Describe the JSON extension here.
</p>


<h3 name="ideas" id="ideas">Future ideas</h3>
<p>
Describe things that may show up later here, such as anonymous templates,
and template blocks that ignore leading and trailing whitespace.
</p>





<p id="footer"> 
<a href="index.html">Table of Contents</a> |
<a href="single_page.html">Single Page Version</a> |
<a href="https://github.com/supernovus/garden-spec/">Source</a>
</p>
</body>
</html>

